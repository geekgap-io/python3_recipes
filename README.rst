A collection of practical recipes to master Python3 in depth
------------------------------------------------------------

Youtube Playlist:
-----------------
https://www.youtube.com/playlist?list=PL65WWXwuCK3ZgVSgSTp-jkdRk6rJUxy77


Table Of Content:
-----------------

- Sequences
    1.     Built-in sequences overview
    2.     Sequence transformation: map and filter
    3.     Sequence comprehension
    4.     Nested Lists
    5.     Sequence unpacking
    6.     Sequence indexing and slicing
    7.     Named Tuples
    8.     Arithmetic operations on Sequences
    9.     Sorting a List: list.sort vs sorted
    10.     Sorting with a custom key: itemgetter, attrgetter and lambda
    11.     Being clever with sorted sequences: search and insertion
    12.     Never update a List while iterating on it
    13.     When not to use a List

- Dicts and Sets
    1.     HashTables overview
    2.     Get, Setdefault and Defaultdict
    3.     Variants of Dict: OrderedDict, ChainMap, Counter
    4.     Read-Only Dict: MappingProxyType
    5.     Immutable Set: FrozenSet
    6.     Set theory: union, intersection, sub, xor
    7.     Never update a Dict/Set while iterating on it
    8.     Sequences vs HashTables:  When to use What
    9.     The insertion order matters

- Functions
    1.     Parameters annotations
    2.     Parameters inspection
    3.     *args and **kwargs: functions with infinite parameters
    4.     *args and **kwargs: functions with keyword-only parameters
    5.     Returning multiple values at once
    6.     Functions are first class citizens
    7.     Turning any object into a function with __call__()
    8.     Anonymous functions with lambda()
    9.     functools.partial(): freezing some parameters of a function
    10.     Functions attributes
    11.     What is a callback
    12.     What is the “callback-hell"
    13.     Functional programming: The operator module
    14.     Functional programming: The functools module

- Closures and Decorators
    1.     Variable scope rules: LEGB
    2.     Functions sharing internal state across calls: welcome closures
    3.     Turning a single-method class into a function
    4.     Altering a variable scope: nonlocal, global
    5.     Updating a closure internal state from outside
    6.     Callbacks with internal state: 4 different ways
    7.     Altering a function behaviour from another function: welcome decorators
    8.     built-in decorators: a quick tour
    9.     Stacking multiple decorators
    10.     Writing “polite” decorators with functools.wrap( )
    11.     Un-decorating a decorated function
    12.     Decorator with arguments
    13.     Decorator with adjustable attributes
    14.     Decorator with optional arguments
    15.     Adding type checking to a function using a decorator

- Iterators and Generators

- Context managers

- Coroutines
    1.     How to escape the "callback-hell” with coroutines

- Concurrency with Processes

- Concurrency with Threads

- Concurrency with AsyncIO

- Object-Oriented: Classes and Objects
    1.     Class based context managers

- Object-Oriented: Inheritance

- Object-Oriented: Interfaces

- Metaprogramming

- Modules and Packages
    1.     Relative import
    2.     Absolute import
    3.     Customise import with __all__ and __init__.py
    4.     globals( )

- Exceptions handling and Debugging

- Strings and Text
    1.     Major differences with Python2

- Numbers and Date-times

- Files and I/O

- Network Programming

- C Extensions