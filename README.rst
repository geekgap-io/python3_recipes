1. Quick Tour:
    1. variables and expressions
    2. Conditions: if/elif/else
    3. While loop
    4. For lop
    5. Exceptions handling: try/except/else/finally
    6. Functions
    7. Classes
    8. Modules
2. Sequences
    1. Built-in sequences overview
    2. Sequence transformation: map and filter
    3. Sequence comprehension
    4. Nested Lists
    5. Sequence unpacking
    6. Sequence indexing and slicing
    7. Named Tuples
    8. Arithmetic operations on Sequences
    9. Sorting a List: list.sort vs sorted
    10. Sorting with a custom key: attrgetter and lambda
    11. Searching a Sequence: bisect
    12. Inserting in a Sequence: bisect.insort
    13. Never update a List while iterating on it
    14. When not to use a List
3. Dicts and Sets
    1. HashTables overview
    2. Dict and Set comprehension
    3. Get and Setdefault
    4. Defaultdict
    5. Variants of Dict: OrderedDict, ChainMap, Counter
    6. Immutable Dict: MappingProxyType
    7. Set theory: union, intersection, sub, xor
    8. Never update a Dict/Set while iterating on it
    9. Not everything can be used a key
    10. Sequences vs HashTables:  When to use What
4. Functions
    1. Parameters annotations
    2. Parameters introspection
    3. Positional and Keyword parameters
    4. Everything to know about *args and **kwargs
    5. Returning multiple values at once
    6. Functions are first class citizens
    7. Functions attributes
    8. Anonymous functions: lambda
    9. What is a callback
    10. What is the “callback-hell"
    11. Functional programming: The operator module
    12. Functional programming: The functools module
5. Closures and Decorators
    1. Variable scope rules: LEGB
    2. Functions sharing internal state across calls: welcome closures
    3. Altering a variable scope: nonlocal, global
    4. Updating a closure internal state from outside
    5. Callbacks with internal state: 4 different ways
    6. Altering a function behaviour from another function: welcome decorators
    7. built-in decorators: a quick tour
    8. Stacking multiple decorators
    9. Writing “polite” decorators with functools.wrap( )
    10. Un-decorating a decorated function
    11. Decorator with arguments
    12. Decorator with adjustable attributes
    13. Decorator with optional arguments
    14. Adding type checking to a function using a decorator
6. Iterators and Generators
7. Context managers
8. Coroutines
    1. How to escape the "callback-hell” with coroutines
9. Concurrency with Processes
10. Concurrency with Threads
11. Concurrency with AsyncIO
12. Object-Oriented: Classes and Objects
    1. Class based context managers
13. Object-Oriented: Inheritance
14. Object-Oriented: Interfaces
15. Metaprogramming
16. Modules and Packages
    1. Relative import
    2. Absolute import
    3. Customise import with __all__ and __init__.py
    4. globals( )
17. Exceptions handling and Debugging
18. Strings and Text
    1. Major differences with Python2
19. Numbers and Date-times
20. Files and I/O
21. Network Programming
22. C Extensions